// com.app.view.View3D// Adam Riggs//package com.app.view {	import away3d.core.base.Vertex;		import com.adam.events.MuleEvent;	import com.adam.utils.AppData;	import com.adobe.utils.AGALMiniAssembler;	import com.adobe.utils.PerspectiveMatrix3D;		import flash.display.Sprite;	import flash.display3D.Context3D;	import flash.display3D.Context3DProgramType;	import flash.display3D.Context3DRenderMode;	import flash.display3D.Context3DVertexBufferFormat;	import flash.display3D.IndexBuffer3D;	import flash.display3D.Program3D;	import flash.display3D.VertexBuffer3D;	import flash.events.*;	import flash.geom.Matrix3D;	import flash.geom.Vector3D;	import flash.utils.getTimer;
		public class View3D extends Sprite{				//vars		protected var _vertices:Vector.<Number>;		protected var _indices:Vector.<uint>;		protected var _otherData:Vector.<Number>;				protected var _vertexShaderCode:String;		protected var _fragmentShaderCode:String;				protected var _startVertex:uint;		protected var _numVertices:uint;		protected var _dataPerVertex:uint;		protected var _startIndex:uint;		protected var _numIndices:uint;				protected var _aspect:Number;		protected var _zNear:Number;		protected var _zFar:Number;		protected var _fov:Number;				//objects		protected var appData:AppData=AppData.instance;		protected var _context3D:Context3D;		protected var _program3D:Program3D;		protected var _vertexBuffer:VertexBuffer3D;		protected var _otherBuffer:VertexBuffer3D;		protected var _indexBuffer:IndexBuffer3D;		protected var _vertexShader:AGALMiniAssembler;		protected var _fragmentShader:AGALMiniAssembler;		protected var _projectionTransform:PerspectiveMatrix3D;		protected var _rotationMatrix:Matrix3D;				//const		public const NAME:String="view3D";		public const RETURNTYPE:String=NAME;				/** Storage for the singleton instance. */		private static const _instance:View3D = new View3D(View3DLock);				public function View3D(lock:Class){			// Verify that the lock is the correct class reference.			if (lock != View3DLock)			{				throw new Error("Invalid View3D access.  Use View3D.instance instead.");			} else {				//init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();						if(stage){				debug("stage");				addEventListener(Event.CONTEXT3D_CREATE, onContext3D, false, 0, true);			} else {				debug("!stage");				addEventListener(Event.ADDED_TO_STAGE, onAddedToStage,false,0,true);			}		}				protected function initVars():void{						//vertices			_startVertex=0;			_numVertices=4;			_dataPerVertex=6;			_vertices=Vector.<Number>([				-.3,-.3,  0, 1, 0, 0, // x, y, z, r, g, b				-.3, .3,  0, 0, 1, 0,				 .3, .3,  0, 0, 0, 1,				  0,  0,-.3, 1, 1, 0			]);						//indices			_startIndex=0;			_numIndices=12;			_indices=Vector.<uint>([				0, 1, 2, 				0, 3, 1,				1, 3, 2,				2, 3, 0			]);						//other data			_otherData=Vector.<Number>([.1,.1,.1,.1,.1]);						//shader opcode			_vertexShaderCode=				"m44 op, va0, vc0\n" + // pos to clipspace				"mov v0, va1" ; // copy rgb						//fragment opcode			_fragmentShaderCode=				"mov ft0, v0\n" +				"mov oc, ft0";						//perspective			_aspect=4/3;			_zNear=.1;			_zFar=1000;			_fov=45*Math.PI/180;		}				protected function initEvents():void{			appData.eventManager.listen(NAME, onView3D);			addEventListener(Event.ENTER_FRAME, onEnterFrame, false, 0, true);		}				protected function initObjs():void{			_vertexShader=new AGALMiniAssembler(true);			_vertexShader.assemble(Context3DProgramType.VERTEX,_vertexShaderCode);			if(_vertexShader.error){				debug("_vertexShader.error=="+_vertexShader.error);			}						_fragmentShader=new AGALMiniAssembler(true);			_fragmentShader.assemble(Context3DProgramType.FRAGMENT,_fragmentShaderCode);			if(_fragmentShader.error){				debug("_fragmentShader.error=="+_fragmentShader.error);			}						_projectionTransform=new PerspectiveMatrix3D();			_projectionTransform.perspectiveFieldOfViewLH(_fov,_aspect,_zNear,_zFar);		}				protected function init3D():void{			debug("init3D()");						_context3D=stage.stage3Ds[0].context3D;			configureBackBuffer();						_vertexBuffer=_context3D.createVertexBuffer(_numVertices, _dataPerVertex);			_vertexBuffer.uploadFromVector(_vertices,_startVertex,_numVertices);						_indexBuffer=_context3D.createIndexBuffer(_numIndices);			_indexBuffer.uploadFromVector(_indices,_startIndex,_numIndices);						_program3D=_context3D.createProgram();			_program3D.upload(_vertexShader.agalcode,_fragmentShader.agalcode);		}						//*****Core Functionality				protected function configureBackBuffer(width:int=800,height:int=600):void{			_context3D.configureBackBuffer(width,height,0,true);		}		//*****Event Handlers				protected function onEnterFrame(e:Event):void{			if(!_context3D){				return;			}						_rotationMatrix=new Matrix3D();			//_rotationMatrix.appendRotation(getTimer()/10, Vector3D.Y_AXIS);			_rotationMatrix.appendRotation(getTimer()/40, Vector3D.X_AXIS);			_rotationMatrix.appendRotation(getTimer()/40, Vector3D.Z_AXIS);			_rotationMatrix.appendTranslation(0,0,2);			_rotationMatrix.append(_projectionTransform);						_context3D.clear(0,0,0,1);			_context3D.setVertexBufferAt(0,_vertexBuffer,0,Context3DVertexBufferFormat.FLOAT_3);			_context3D.setVertexBufferAt(1,_vertexBuffer,3,Context3DVertexBufferFormat.FLOAT_3);						_context3D.setProgram(_program3D);			_context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX,0,_rotationMatrix,true);			_context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT,0,_otherData);			_context3D.drawTriangles(_indexBuffer);			_context3D.present();		}				protected function onAddedToStage(e:Event):void{			debug("onAddedToStage()");			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, onContext3D, false, 0, true);			stage.stage3Ds[0].requestContext3D(Context3DRenderMode.AUTO);		}				protected function onContext3D(e:Event):void{			debug("onContext3D()");			stage.stage3Ds[0].removeEventListener(Event.CONTEXT3D_CREATE, onContext3D);			debug("stage.stage3Ds[0].context3D.driverInfo=="+stage.stage3Ds[0].context3D.driverInfo);			init3D();		}				protected function onView3D(e:MuleEvent):void{			/*debug("onView3D()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){								default:					debug("onView3D()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);					break;							}		}				//*****Gets and Sets				public static function get instance():View3D{return _instance;}		//*****Utility Functions				//**visibility		public function show():void{			this.visible = true;		}				public function hide():void{			this.visible = false;		}				//**debug		protected function debug(str:String):void{			appData.debug(NAME,str);		}				}//end class}//end packageclass View3DLock{}