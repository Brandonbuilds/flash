// com.app.view.View3D// Adam Riggs//package com.app.view {	import away3d.core.base.Vertex;		import com.adam.events.MuleEvent;	import com.adam.utils.AppData;	import com.adobe.utils.AGALMiniAssembler;	import com.adobe.utils.PerspectiveMatrix3D;		import flash.display.Bitmap;	import flash.display.Sprite;	import flash.display3D.Context3D;	import flash.display3D.Context3DProgramType;	import flash.display3D.Context3DRenderMode;	import flash.display3D.Context3DTextureFormat;	import flash.display3D.Context3DVertexBufferFormat;	import flash.display3D.IndexBuffer3D;	import flash.display3D.Program3D;	import flash.display3D.VertexBuffer3D;	import flash.display3D.textures.Texture;	import flash.events.*;	import flash.geom.Matrix3D;	import flash.geom.Vector3D;	import flash.utils.getTimer;
		public class View3D extends Sprite{				//vars		protected var _geometryVertices:Vector.<Number>;		protected var _indices:Vector.<uint>;				protected var _vertexShaderCode:String;		protected var _fragmentShaderCode:String;				protected var _gvStart:uint;		protected var _gvCount:uint;		protected var _gvSize:uint;		protected var _startIndex:uint;		protected var _numIndices:uint;				protected var _aspect:Number;		protected var _zNear:Number;		protected var _zFar:Number;		protected var _fov:Number;				protected var _spList:Vector.<uint>;		protected var _spCount:uint;				//objects		protected var appData:AppData=AppData.instance;		protected var _context3D:Context3D;		protected var _program3D:Program3D;		protected var _geometryBuffer:VertexBuffer3D;		protected var _textureBuffer:VertexBuffer3D;		protected var _indexBuffer:IndexBuffer3D;		protected var _vertexShader:AGALMiniAssembler;		protected var _fragmentShader:AGALMiniAssembler;		protected var _projectionTransform:PerspectiveMatrix3D;		protected var _rotationMatrix:Matrix3D;				protected var _spriteSheet:SpriteSheet;				protected var _texture:Texture;				[Embed(source="mario.png")]		protected const TextureBitmap:Class;		protected var _textureBitmap:Bitmap;				//const		public const NAME:String="view3D";		public const RETURNTYPE:String=NAME;				/** Storage for the singleton instance. */		private static const _instance:View3D = new View3D(View3DLock);				public function View3D(lock:Class){			// Verify that the lock is the correct class reference.			if (lock != View3DLock)			{				throw new Error("Invalid View3D access.  Use View3D.instance instead.");			} else {				//init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();						if(stage){				debug("stage");				addEventListener(Event.CONTEXT3D_CREATE, onContext3D, false, 0, true);			} else {				debug("!stage");				addEventListener(Event.ADDED_TO_STAGE, onAddedToStage,false,0,true);			}		}				protected function initVars():void{						//geometry vertices			_gvStart=0;			_gvCount=4;			_gvSize=3;			_geometryVertices=Vector.<Number>([				-.3,-.3,  0, // x, y, z				-.3, .3,  0,				 .3, .3,  0,				 .3,-.3,  0			]);						//indices			_startIndex=0;			_numIndices=6;			_indices=Vector.<uint>([0, 1, 2, 2, 3, 0]);						//shader opcode			_vertexShaderCode=				"m44 op, va0, vc0\n" + // pos to clipspace				"mov v0, va1" ; // copy uv						//fragment opcode			_fragmentShaderCode=				"tex ft1, v0, fs0 <2d>\n" +				"mov oc, ft1";						//perspective			_aspect=4/3;			_zNear=.1;			_zFar=1000;			_fov=45*Math.PI/180;						//bitmap			_textureBitmap=new TextureBitmap();						//sprites			_spList=Vector.<uint>([24,25,26,27,24,25,26,27,24,25,26,27,35,36,35,36,35,36,35,36]);			_spCount=0;		}				protected function initEvents():void{			appData.eventManager.listen(NAME, onView3D);			addEventListener(Event.ENTER_FRAME, onEnterFrame, false, 0, true);		}				protected function initObjs():void{			_vertexShader=new AGALMiniAssembler(true);			_vertexShader.assemble(Context3DProgramType.VERTEX,_vertexShaderCode);			if(_vertexShader.error){				debug("_vertexShader.error=="+_vertexShader.error);			}						_fragmentShader=new AGALMiniAssembler(true);			_fragmentShader.assemble(Context3DProgramType.FRAGMENT,_fragmentShaderCode);			if(_fragmentShader.error){				debug("_fragmentShader.error=="+_fragmentShader.error);			}						_projectionTransform=new PerspectiveMatrix3D();			_projectionTransform.perspectiveFieldOfViewLH(_fov,_aspect,_zNear,_zFar);						_spriteSheet=new SpriteSheet(_textureBitmap.bitmapData,8,8);					}				protected function init3D():void{			debug("init3D()");						_context3D=stage.stage3Ds[0].context3D;			configureBackBuffer();						_geometryBuffer=_context3D.createVertexBuffer(_gvCount, _gvSize);			_geometryBuffer.uploadFromVector(_geometryVertices,_gvStart,_gvCount);						_textureBuffer=_context3D.createVertexBuffer(_spriteSheet.texCount, _spriteSheet.texSize);						_indexBuffer=_context3D.createIndexBuffer(_numIndices);			_indexBuffer.uploadFromVector(_indices,_startIndex,_numIndices);						_program3D=_context3D.createProgram();			_program3D.upload(_vertexShader.agalcode,_fragmentShader.agalcode);						_texture = _context3D.createTexture(_textureBitmap.bitmapData.width, _textureBitmap.bitmapData.height, Context3DTextureFormat.BGRA, false);			_texture.uploadFromBitmapData(_textureBitmap.bitmapData);		}						//*****Core Functionality				protected function configureBackBuffer(width:int=800,height:int=600):void{			_context3D.configureBackBuffer(width,height,0,true);		}		//*****Event Handlers				protected function onEnterFrame(e:Event):void{			if(!_context3D){				return;			}						_rotationMatrix=new Matrix3D();			//_rotationMatrix.appendRotation(getTimer()/10, Vector3D.Y_AXIS);//			_rotationMatrix.appendRotation(getTimer()/40, Vector3D.X_AXIS);//			_rotationMatrix.appendRotation(getTimer()/40, Vector3D.Z_AXIS);			_rotationMatrix.appendTranslation(0,0,6);			_rotationMatrix.append(_projectionTransform);						_context3D.clear(0,0,0,1);						_textureBuffer.uploadFromVector(_spriteSheet.getSpriteMatrix(_spList[_spCount]), _spriteSheet.texStart, _spriteSheet.texCount);						_context3D.setVertexBufferAt(0,_geometryBuffer,0,Context3DVertexBufferFormat.FLOAT_3);			_context3D.setVertexBufferAt(1,_textureBuffer,0,Context3DVertexBufferFormat.FLOAT_2);			_context3D.setTextureAt(0,_texture);						_context3D.setProgram(_program3D);			_context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX,0,_rotationMatrix,true);			_context3D.drawTriangles(_indexBuffer);			_context3D.present();						_spCount++;			if(_spCount>=_spList.length){				_spCount=0;			} 		}				protected function onAddedToStage(e:Event):void{			debug("onAddedToStage()");			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, onContext3D, false, 0, true);			stage.stage3Ds[0].requestContext3D(Context3DRenderMode.AUTO);		}				protected function onContext3D(e:Event):void{			debug("onContext3D()");			stage.stage3Ds[0].removeEventListener(Event.CONTEXT3D_CREATE, onContext3D);			debug("stage.stage3Ds[0].context3D.driverInfo=="+stage.stage3Ds[0].context3D.driverInfo);			init3D();		}				protected function onView3D(e:MuleEvent):void{			/*debug("onView3D()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){								default:					debug("onView3D()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);					break;							}		}				//*****Gets and Sets				public static function get instance():View3D{return _instance;}		//*****Utility Functions				//**visibility		public function show():void{			this.visible = true;		}				public function hide():void{			this.visible = false;		}				//**debug		protected function debug(str:String):void{			appData.debug(NAME,str);		}				}//end class}//end packageclass View3DLock{}